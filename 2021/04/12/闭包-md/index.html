<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="沐源山"><meta name="copyright" content="沐源山"><meta name="generator" content="Hexo 5.3.0"><meta name="theme" content="hexo-theme-yun"><title>闭包.md | MYS</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.22/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"muyuanshan.github.io","root":"/","title":"沐源山的小站","version":"1.3.0","mode":"auto","copycode":true,"say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><meta name="description" content="针对于闭包，是一个我感觉比较不好理解的一个点，下面是我对闭包的一些理解。 闭包的理解闭包是如何产生的？当一个嵌套的函数的内部（子）函数引用了嵌套外部（父）函数的变量（函数）时，就已经产生了闭包。当然这个外部函数一定要被调用才行。外部函数调用，产生了外部函数的作用域。我们可以使用Chrome来查看闭包，如下图所示： 如上图所示，closure代表的就是闭包。在左侧的代码中内部函数fn2里面引用了外层">
<meta property="og:type" content="article">
<meta property="og:title" content="闭包.md">
<meta property="og:url" content="https://muyuanshan.github.io/2021/04/12/%E9%97%AD%E5%8C%85-md/index.html">
<meta property="og:site_name" content="MYS">
<meta property="og:description" content="针对于闭包，是一个我感觉比较不好理解的一个点，下面是我对闭包的一些理解。 闭包的理解闭包是如何产生的？当一个嵌套的函数的内部（子）函数引用了嵌套外部（父）函数的变量（函数）时，就已经产生了闭包。当然这个外部函数一定要被调用才行。外部函数调用，产生了外部函数的作用域。我们可以使用Chrome来查看闭包，如下图所示： 如上图所示，closure代表的就是闭包。在左侧的代码中内部函数fn2里面引用了外层">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva4.sinaimg.cn/large/0068gb2Yly1gpo19dusk7j31hc0akaet.jpg">
<meta property="og:image" content="https://tvax3.sinaimg.cn/large/0068gb2Yly1gpo1f8ii1rj30qa0bota8.jpg">
<meta property="og:image" content="https://tva2.sinaimg.cn/large/0068gb2Yly1gpo1stl82pj30w30bsdl8.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0068gb2Yly1gpo2fk40paj30z00qomzs.jpg">
<meta property="og:image" content="https://tva4.sinaimg.cn/large/0068gb2Yly1gpo2ioz955j30p8076my5.jpg">
<meta property="og:image" content="https://tvax1.sinaimg.cn/large/0068gb2Yly1gpo71w5pmzj30ki09v0u6.jpg">
<meta property="og:image" content="https://tva4.sinaimg.cn/large/0068gb2Yly1gpo73yk1c4j30l60alwfy.jpg">
<meta property="og:image" content="https://tvax4.sinaimg.cn/large/0068gb2Yly1gpo7760b7jj30lr0bumy9.jpg">
<meta property="og:image" content="https://tvax4.sinaimg.cn/large/0068gb2Yly1gpo7aq01ndj31600k60yo.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0068gb2Yly1gpo7el3xt9j30m90antaa.jpg">
<meta property="og:image" content="https://tva4.sinaimg.cn/large/0068gb2Yly1gpo7j2l9dhj312k0du78m.jpg">
<meta property="og:image" content="https://tva2.sinaimg.cn/large/0068gb2Yly1gpo7nv8qswj317w0agadx.jpg">
<meta property="article:published_time" content="2021-04-12T03:43:50.000Z">
<meta property="article:modified_time" content="2021-04-18T13:26:03.688Z">
<meta property="article:author" content="沐源山">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva4.sinaimg.cn/large/0068gb2Yly1gpo19dusk7j31hc0akaet.jpg"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="沐源山"><img width="96" loading="lazy" src="/images.jpeg" alt="沐源山"></a><div class="site-author-name"><a href="/about/">沐源山</a></div><a class="site-name" href="/about/site.html">MYS</a><sub class="site-subtitle">永远相信美好的事情即将发生</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">6</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">1</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">3</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/muyuanshan" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/5618863396/profile?topnav=1&amp;wvr=6" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=441238633" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">闭包的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-number">2.</span> <span class="toc-text">常见的闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B0%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.1.</span> <span class="toc-text">一、将函数作为另一个函数的返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B0%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AE%9E%E5%8F%82%E4%BC%A0%E9%80%92%E7%BB%99%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">二、将函数作为实参传递给另一个函数调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">闭包有哪些作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.</span> <span class="toc-text">闭包的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">闭包的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89js%E6%A8%A1%E5%9D%97"><span class="toc-number">5.1.</span> <span class="toc-text">自定义js模块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88GC"><span class="toc-number">6.</span> <span class="toc-text">垃圾回收机制（GC)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.1.</span> <span class="toc-text">内存的生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">回收的方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">6.4.</span> <span class="toc-text">垃圾回收的时机</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86"><span class="toc-number">6.4.1.</span> <span class="toc-text">分代收集</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86"><span class="toc-number">6.4.2.</span> <span class="toc-text">增量收集</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%97%B2%E6%97%B6%E6%94%B6%E9%9B%86"><span class="toc-number">6.4.3.</span> <span class="toc-text">闲时收集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number">7.</span> <span class="toc-text">最后</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://muyuanshan.github.io/2021/04/12/%E9%97%AD%E5%8C%85-md/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="沐源山"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="MYS"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">闭包.md</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-04-12 11:43:50" itemprop="dateCreated datePublished" datetime="2021-04-12T11:43:50+08:00">2021-04-12</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-04-18 21:26:03" itemprop="dateModified" datetime="2021-04-18T21:26:03+08:00">2021-04-18</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E5%89%8D%E7%AB%AF/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">前端</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/js/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">js</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><p>针对于闭包，是一个我感觉比较不好理解的一个点，下面是我对闭包的一些理解。</p>
<h4 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h4><p>闭包是如何产生的？当一个嵌套的函数的内部（子）函数引用了嵌套外部（父）函数的变量（函数）时，就已经产生了闭包。当然这个外部函数一定要被调用才行。外部函数调用，产生了外部函数的作用域。<br>我们可以使用Chrome来查看闭包，如下图所示：<br><img src="https://tva4.sinaimg.cn/large/0068gb2Yly1gpo19dusk7j31hc0akaet.jpg" alt="Chrome查看闭包" loading="lazy"></p>
<p>如上图所示，closure代表的就是闭包。在左侧的代码中内部函数fn2里面引用了外层函数的变量a，fn2并没有执行 但是闭包就已经产生了。闭包的产生是根据词法作用域来的，有函数的声明位置决定。现在我们把fn2执行一下。<br><img src="https://tvax3.sinaimg.cn/large/0068gb2Yly1gpo1f8ii1rj30qa0bota8.jpg" alt="内部函数执行产生的结果" loading="lazy"><br>更清晰的看到了闭包。</p>
<p>大多人的都是认为闭包是嵌套的内部函数，但也有的人认为闭包是包含被引用变量（函数）的对象。但是无论是哪一个，我们都能得到产生闭包的条件。</p>
<ol>
<li>函数必须是嵌套的</li>
<li>内部函数必须引用了外部函数的数据（函数/变量）</li>
</ol>
<h4 id="常见的闭包"><a href="#常见的闭包" class="headerlink" title="常见的闭包"></a>常见的闭包</h4><h5 id="一、将函数作为另一个函数的返回值"><a href="#一、将函数作为另一个函数的返回值" class="headerlink" title="一、将函数作为另一个函数的返回值"></a>一、将函数作为另一个函数的返回值</h5><pre><code>function fn1() &#123;
  var a = 2;
  function fn2() &#123;
    a++;
    console.log(a);
  &#125;
  return fn2;
&#125;
var f = fn1();
f(); // 3
f(); // 4</code></pre>
<p>在上述代码的整个过程中产生了几个闭包？1个。因为整个过程中只创建了一个函数，只是单纯的调用了两次，并有创建函数。由此我们得出结论，<strong>创建了几个闭包，需要看外部函数被创建了几次，和内部函数调用几次是没有关系的</strong>。</p>
<h5 id="二、将函数作为实参传递给另一个函数调用"><a href="#二、将函数作为实参传递给另一个函数调用" class="headerlink" title="二、将函数作为实参传递给另一个函数调用"></a>二、将函数作为实参传递给另一个函数调用</h5><p>且看下面的这张图：<br><img src="https://tva2.sinaimg.cn/large/0068gb2Yly1gpo1stl82pj30w30bsdl8.jpg" alt="闭包-函数作为实参传递" loading="lazy"></p>
<p><code>setTimeout</code> 函数中第一个参数是一个函数，其作为内部函数。在这个内部函数中引用了<code>msg</code>，所以这就形成了闭包。</p>
<h4 id="闭包有哪些作用"><a href="#闭包有哪些作用" class="headerlink" title="闭包有哪些作用"></a>闭包有哪些作用</h4><p>使用函数内部的变量在函数执行完成之后，仍然存活在内存中，延长了局部变量的生命周期。让外部函数可以操作（读写）到函数内部的数据（变量或者函数）。<br>看下面这段代码：</p>
<pre><code>function fn1() &#123;
  var a = 2;
  function fn2() &#123;
    a++;
    console.log(a);
  &#125;
  function fn3() &#123;
    a--;
    console.log(a);
  &#125;
  return fn3;
&#125;
var f = fn1();
f(); // 1;</code></pre>
<p>在函数执行的过程中，fn2并没有被引用，在函数执行完成之后会被自动释放。变量fn3也被释放了，因为变量fn3不在闭包里面，<code>return</code> 出来的是函数的地址，用来赋给变量f，在函数里面引用了外部函数的变量<code>a</code>所以fn3函数就形成了闭包，a没有消失。</p>
<h4 id="闭包的生命周期"><a href="#闭包的生命周期" class="headerlink" title="闭包的生命周期"></a>闭包的生命周期</h4><p><strong>产生</strong>：在嵌套内部函数定义执行完成时就已经产生了（不是在调用的时候）<br><strong>死亡</strong>：在嵌套的内部函数成为垃圾对象的时候死亡</p>
<p>看下面的这段代码：</p>
<pre><code>function fn1() &#123;
  var a = 1
  // 此时闭包已经存在（函数的提升，内部函数对象已经被创建了）
  function fn2() &#123;
    a++
    console.log9(a)
  &#125;
  return fn2
&#125;
var f = fn1()
f()
f = null // 此时闭包死亡</code></pre>
<h4 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h4><p>我们已经知道闭包是什么了，那么它能干些什么呢？</p>
<h5 id="自定义js模块"><a href="#自定义js模块" class="headerlink" title="自定义js模块"></a>自定义js模块</h5><p>定义具有特定功能的js文件，将所有数据和功能都封在一个函数内部（私有的），只向外暴露一个包含n个方法的对象或函数，模块的使用者，只需要通过模块暴露的对象调用来实现对应的功能<br><img src="https://tva1.sinaimg.cn/large/0068gb2Yly1gpo2fk40paj30z00qomzs.jpg" alt="私有模块" loading="lazy"><br>在想使用的地方进行使用<br><img src="https://tva4.sinaimg.cn/large/0068gb2Yly1gpo2ioz955j30p8076my5.jpg" alt="调用私有模块" loading="lazy"></p>
<h4 id="垃圾回收机制（GC"><a href="#垃圾回收机制（GC" class="headerlink" title="垃圾回收机制（GC)"></a>垃圾回收机制（GC)</h4><p>在上面我们说到，函数执行完成之后，会回收没有用的“垃圾”。那么浏览器是怎么进行垃圾回收的呢？</p>
<h5 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h5><ol>
<li>分配你所需要的的内存<br>由于字符串、对象等没有固定的大小，js在每次执行的时候，程序都会分配内存来存储那个实体。</li>
<li>使用分配的内存做点什么</li>
<li>不需要的时候将其释放回归<br>在不需要的时候，需要释放其占用的内存，否则将会消耗完系统中的所有可用的内存，造成系统崩溃，这就是<strong>垃圾回收的意义</strong><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5>垃圾收集器会按照固定的时间间隔，周期性的找出不再继续使用的变量，然后释放其占用的内存。那么有一个问题，什么叫不再使用的变量呢？<br>不再使用的变量也就是生命周期结束的变量，是局部变量（全局变量的生命周期直至浏览的卸载页面的时候才会结束，不会被回收）。局部变量在函数的执行过程中存在，但函数运行结束后，没有其他的引用（比如闭包），那么该变量就会被标记回收。</li>
</ol>
<h5 id="回收的方式"><a href="#回收的方式" class="headerlink" title="回收的方式"></a>回收的方式</h5><p>回收的方式有两种：</p>
<ol>
<li>标记清除：目前最常用的垃圾回收策略<br>工作原理：当变量进入环境时，将这个变量标记为“进入环境”，当这个变量离开的时候，则被标记为“离开环境”，标记为“离开环境”就会被回收。<br>工作流程：</li>
</ol>
<ul>
<li>垃圾收集器会在运行的时候会给存储在内存中所有变量都打上标记。</li>
<li>去掉环境中的变量已经被环境中的引用的变量的标记</li>
<li>哪些还存在标记的变量被视为准备删除的变量</li>
<li>最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收他们所占用的内存空间</li>
</ul>
<ol start="2">
<li><p>引用计数：被废弃的垃圾回收策略<br>循环引用： 跟踪记录每一个值的引用。这种方法会存在一个问题，如果说两个对象互相包含，那么这个计数就会一直存在，一种清除不掉，就会占用内存。举个🌰：</p>
<p> let element = document.getElementById(‘something’);<br> let myObject = new Object();<br> myObject.element = element; // element属性指向dom<br> element,something = myObject; // something回指myObject 出现看循环引用</p>
</li>
</ol>
<h5 id="垃圾回收的时机"><a href="#垃圾回收的时机" class="headerlink" title="垃圾回收的时机"></a>垃圾回收的时机</h5><p>回收的时间是周期性的 不是实时的。浏览器在回收的过程中，会暂停浏览器的执行js脚本，等垃圾回收完成之后再继续进行。对于普通的页面来讲是没有什么问题的，但是如果对于像游戏和动画，对于这种连贯性动作要求比较高的场景，就不能满足了。如果暂停执行就会造成页面的卡顿。那么我们接下来谈谈，什么时候进行垃圾回收最好？</p>
<h6 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h6><p>浏览器将数据分为两种，一种是「临时」对象，一种是「长就」对象。</p>
<ol>
<li>临时对象</li>
</ol>
<ul>
<li>大部分对象在内存中存活的时间很短。</li>
<li>比如函数内部声明的变量，或者块级作用域中的变量。当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。</li>
<li>这类对象很快就变得不可访问，应该快点回收。</li>
</ul>
<ol start="2">
<li>长久对象</li>
</ol>
<ul>
<li>生命周期很长的对象，比如全局的<code>window</code>、<code>dom</code>、<code>Web API</code>等等。</li>
<li>这类对象可以慢点回收<br>这两种对象对应不同的回收策略，所以V8把堆分为新生代和老生代两个区域，新生代中存放临时对象，老生代中存放对象持久对象。并且让主垃圾回收器和副垃圾回收器，分别负责老生代和新生代的垃圾回收。</li>
</ul>
<p><strong>主垃圾回收器</strong><br>负责老生代的垃圾回收，对象占用空间大，对象存活的时间长。使用的是标记清除法。<br>首先是标记，从一组根元素开始，递归遍历这组根元素。在这个遍历过程中，能到达的元素成为活动对象，没有到达的元素就可以判断为垃圾数据，然后是垃圾清除。<br><img src="https://tvax1.sinaimg.cn/large/0068gb2Yly1gpo71w5pmzj30ki09v0u6.jpg" alt="主回收器-标记清除" loading="lazy"><br>直接将标记为垃圾的数据清理掉。多次清除后会产生大量不连续的内存碎片，需要进行内存整理。<br><img src="https://tva4.sinaimg.cn/large/0068gb2Yly1gpo73yk1c4j30l60alwfy.jpg" alt="主垃圾回收器-整理内存" loading="lazy"></p>
<p><strong>副垃圾回收器</strong><br>负责新生代的垃圾回收，通常只支持1-8M的容量。新生代被分为两个区域：一半是对象区域一半空闲区域。<br><img src="https://tvax4.sinaimg.cn/large/0068gb2Yly1gpo7760b7jj30lr0bumy9.jpg" alt="副垃圾回收器" loading="lazy"></p>
<p>新加入的对象都被放在对象区域，等对象区域快满的时候，会执行一次垃圾清理。<br>清理过程：</p>
<ol>
<li>先给对象区域所有垃圾做标记。</li>
<li>标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍。<br><img src="https://tvax4.sinaimg.cn/large/0068gb2Yly1gpo7aq01ndj31600k60yo.jpg" alt="副垃圾回收器的过程" loading="lazy"><br>在介绍主垃圾回收器的时候发现，垃圾清理是无序的，需要整理一下空间。但是副垃圾回收器的空闲区域是有序排列的所以是不需要整理内存空间的。<br>复制完成之后，对象区域回合空闲区域进行对调。将空闲区域中存活的对象放到对象区域里面。<br><img src="https://tva1.sinaimg.cn/large/0068gb2Yly1gpo7el3xt9j30m90antaa.jpg" alt="副垃圾回收器-对调" loading="lazy"><br>这就完成了垃圾回收。<br>因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置的比较小，一旦检测到空间装满了，就执行垃圾回收。</li>
</ol>
<p>分生代对后用一句话总结就是：将堆分为新生代和老生代，多回收新生代，少回收老生代。这样就减少了每次需要遍历的对象，从而减少垃圾回收的耗时。<br><img src="https://tva4.sinaimg.cn/large/0068gb2Yly1gpo7j2l9dhj312k0du78m.jpg" alt="垃圾回收回收-分生代" loading="lazy"></p>
<p>下面简单介绍一下，剩下的几种办法</p>
<h6 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h6><p>如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间的暂停。所以引擎将垃圾收集工作分成更小的块，每一次处理一部分，多次处理。<br><img src="https://tva2.sinaimg.cn/large/0068gb2Yly1gpo7nv8qswj317w0agadx.jpg" alt="垃圾回收-增量收集" loading="lazy"></p>
<h6 id="闲时收集"><a href="#闲时收集" class="headerlink" title="闲时收集"></a>闲时收集</h6><p>垃圾收集器只会在CPU空闲时进行尝试，以减少可能对代码执行的影响。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>本篇文章就到这里了，下面留一到题：</p>
<pre><code>function fun(n,o) &#123;
  console.log(o);
  return &#123;
    fun1: function(m) &#123;
      return fun(m,n);
    &#125;
  &#125;
&#125;

// 第一种情况
var a = fun(0);
a.fun1(1);
a.fun1(2);
a.fun1(3);

// 第二种情况
var b = fun(0).fun1(1).fun1(2).fun1(3);

// 第三种情况
var c = fun(0).fun1(1);
c.fun1(2);
c.fun1(3);</code></pre>
<p>以上分别输出什么呢？</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>沐源山</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://muyuanshan.github.io/2021/04/12/%E9%97%AD%E5%8C%85-md/" title="闭包.md">https://muyuanshan.github.io/2021/04/12/%E9%97%AD%E5%8C%85-md/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/05/17/%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93-md/" rel="prev" title="数组的方法总结.md"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">数组的方法总结.md</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/03/25/js%E4%BD%9C%E7%94%A8%E5%9F%9F-md/" rel="next" title="js作用域和变量的提升.md"><span class="post-nav-text">js作用域和变量的提升.md</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 沐源山</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.3.0</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>